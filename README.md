Основано на https://github.com/nkihrk/infi-draw

===

Пишем проект - бесконечный общедоступный Canvas.

Веб-страница с бесконечным canvas, где любой человек может что-то нарисовать и это останется навсегда.

Раскладка от GPT:
Итак, ты хочешь **бесконечный общедоступный Canvas**, где любой человек рисует, и это **остаётся навсегда**.
Человечество, конечно, немедленно нарисует там 80% неприличного, 15% свастик и 5% котиков, но технически это реально.

Ниже нормальный, рабочий план, без “а давай просто сделаем бесконечный `<canvas>`”.

---

## Главная идея: “бесконечный” не значит “огромный”

HTML5 canvas не может быть бесконечным. Делается так же, как карты (Google Maps и т.д.):

* есть **камера** (pan/zoom)
* рисуется только **видимая область**
* мир разбит на **тайлы/чанки** (например 512×512 “мировых” единиц)
* клиент грузит и кеширует тайлы вокруг вьюпорта

---

## Данные: пиксели или вектора?

Есть два пути.

### Вариант A (самый правильный для “рисовать”): **векторные штрихи (strokes)**

Ты хранишь не картинку, а действия:

* кто-то провёл линию такой-то кистью, по таким-то точкам
* это навсегда в “журнале событий”

Плюсы:

* “бесконечность” дешёвая
* идеально ложится на “останется навсегда”
* можно сделать **перемотку времени** (time travel)

Минусы:

* чтобы грузилось быстро, нужны **снапшоты/компактация**, иначе тайл будет рендериться из 3 млн линий

### Вариант B (как r/place): **пиксельные операции**

Типа “поставил пиксель (x,y) в цвет”.
Плюсы: проще конфликт-резолв, легче рендер.
Минусы: “рисовать” неудобно (только пиксель-арт), и “навсегда” быстро превращается в гору данных.

**Тебе почти наверняка нужен Вариант A.**

---

## Архитектура, которая не умрёт через неделю

### 1) Append-only журнал (истина)

Все действия рисования пишутся как события:

* `stroke_created`
* `erase_stroke` (лучше не удалять, а скрывать)
* (опционально) `moderation_hide`

Это реально важно: “навсегда” = **не перезаписывать историю**, а наращивать.

Хранилище:

* **PostgreSQL** (в начале хватит)
* дальше: **S3/MinIO** для архивов + Postgres только для индексов/метаданных

### 2) Тайл-сервис (быстро отдавать)

Мир режешь на тайлы по координатам:

* `tile_x = floor(world_x / TILE_SIZE)`
* `tile_y = floor(world_y / TILE_SIZE)`

Каждый stroke кладёшь в те тайлы, которых он касается (пересечение bbox).

Чтобы не рендерить “с нуля”:

* периодически делаешь **снапшот тайла** (например PNG/WebP)
* и поверх него отдаёшь “дельту” событий после снапшота

Схема:

* `tile_snapshots(room_id, tile_x, tile_y, version, snapshot_url)` — снапшоты в MinIO
* `tile_events(room_id, tile_id, id, stroke_id, event_type, payload, ts)` — события по тайлам (по **tile_id**, не bbox)
* `stroke_events` — журнал штрихов (bbox для обратной совместимости)

**Паттерн запросов (чтобы не превратиться в мясорубку):**

* На клиенте/сервере считаем **какие тайлы попадают во вьюпорт** → список `tile_id`.
* В БД ходим **по `tile_id IN (...)`** или одним запросом `tile_id = ANY($1::bigint[])`.
* Не делаем `WHERE x BETWEEN ... AND y BETWEEN ...` по всем событиям — это путь в ад при росте данных.
* `tile_id` — один bigint (кодировка tile_x, tile_y), индексы по `(room_id, tile_id, id)`.
* Дельта: «все события по тайлу где `id > since_id`» — один запрос на много тайлов через `VALUES + JOIN` при необходимости.

**Индексы (минимум):**

* `tile_events`: PK/UNIQUE `(room_id, tile_id, id)`.
* `tile_snapshots`: индекс по `(room_id, tile_x, tile_y)`.
* `stroke_events`: по `room_id`, по bbox только для fallback.

### 3) Реалтайм (чтобы видно было, как рисуют)

WebSocket:

* клиент шлёт stroke кусками (батчами)
* сервер валидирует + rate limit
* сервер публикует событие подписчикам вокруг этого тайла

Внутри можно хоть RabbitMQ (тебе привычно), хоть Redis Pub/Sub.

---

## Клиент (веб) без боли

На фронте нужен не “голый canvas и молитва”, а нормальный рендер-движок:

* **PixiJS** (очень хорошо для 2D)
* или **Konva** (проще, но может упереться раньше)
* или чистый Canvas2D, но с кешированием слоёв

Как оно работает:

* камера меняется (pan/zoom)
* считаешь bbox видимой области
* запрашиваешь нужные тайлы:

  * `GET /tiles?x1=&y1=&x2=&y2=&since_version=...`
* рисуешь:

  * сначала снапшоты (быстро)
  * потом “дельту” штрихов поверх

---

## Формат stroke (пример)

Храни “кисть” и точки. Минимизируй размер:

```json
{
  "id": "uuid",
  "ts": 1730000000,
  "tool": "pen",
  "color": "#111111",
  "width": 3,
  "points": [[10.2, 15.7], [11.0, 16.1], [12.4, 17.8]]
}
```

Оптимизация:

* хранить points как int (умножить на 10 или 100)
* сжимать (msgpack / protobuf)
* на сервере резать stroke на чанки по времени (пока человек ведёт линию)

---

## Самое “весёлое”: злоупотребления

Если ты реально сделаешь “любой человек и навсегда”, то тебе нужны хотя бы базовые тормоза:

**Минимум:**

* rate limit по IP (и по fingerprint)
* капча при аномальной активности
* лимит длины stroke / частоты сообщений
* анти-бот (хотя бы proof-of-work токен на сессию)

**Модерация (иначе проект станет помойкой):**

* репорты
* скрытие контента (не удаление из лога, а “hidden layer”)
* публичные правила и возможность законного takedown (да, “навсегда” заканчивается там, где начинаются юристы)

---

## MVP за адекватное время (чтобы не утонуть)

1. **Только pen** (без ластика, без слоёв, без фигур)
2. Тайл 512×512, только zoom/pan
3. Хранение strokes в Postgres + индекс по тайлам
4. `GET /tiles` отдаёт strokes за тайл
5. WebSocket: транслировать новые strokes тем, кто смотрит тайл
6. Потом: снапшоты тайлов (рендер в PNG/WebP) + дельта

---

## Если хочешь “вау”-фичу, которая реально выделит проект

* **ползунок времени**: посмотреть, как canvas рос
* “тепловая карта” активности
* подписи/анонимные “теги” авторов (не обязательно аккаунты)
* “вкладка археолога”: показывать первые штрихи в регионе

---

## Итог (чтобы было понятно, что именно строить)

**Правильная модель**: *event sourcing + тайлы + снапшоты + realtime*.
Иначе это будет либо:

* “бесконечный canvas” на 3 минуты до краша вкладки,
* либо база данных, которая захлебнулась в JPEG-ах.

Если делать по схеме выше, это будет жить и масштабироваться, и “навсегда” будет не просто пафосным словом, а нормальной инженерной характеристикой (с поправкой на реальность и юристов, к сожалению).
