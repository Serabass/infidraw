# Оптимизация размера ответов API (GET /events и др.)

Проблема: в комнате с большим холстом GET `/api/events?roomId=1` отдаёт ~19 MB JSON (десятки тысяч событий). Ниже — варианты, от быстрых до более трудоёмких.

---

## 1. Сокращать размер чанка (пагинация / streaming)

**Суть:** не отдавать 10 000 событий одним ответом. Отдавать порциями (например 500–1000), клиент запрашивает следующую порцию по `since=<lastTimestamp>`.

**Сейчас:**
- При `since=0` лимит по умолчанию **10 000** (`event-store`: `since === 0 ? 10000 : 100`).
- Фронт при загрузке комнаты вызывает `getStrokes(0, roomId)` без `limit` — получает до 10 000 событий разом (~19 MB).

**Что сделать:**
- **Бэкенд:** уменьшить дефолтный лимит при `since=0` (например 500–1000) или оставить 10 000, но явно документировать пагинацию.
- **Фронт:** при первом заходе в комнату не ждать один огромный ответ. Варианты:
  - **A) Последовательная пагинация:** первый запрос `GET /events?roomId=1&limit=500`, по приходе — второй `GET /events?roomId=1&since=<lastTs>&limit=500`, и так пока событий не станет меньше `limit`. Холст заполняется постепенно.
  - **B) Tiles-first:** уже есть `loadTiles()` по видимой области. Можно при старте **сначала** грузить только тайлы для текущего вьюпорта (лёгкий ответ), отображать снапшоты, а события подтягивать порциями в фоне или только инкремент (`since`) после последнего события тайлов. Тогда «первая краска» не зависит от полного лога событий.

**Плюсы:** один ответ сразу становится в разы меньше, время до первого отображения падает.  
**Минусы:** несколько запросов вместо одного; нужно аккуратно склеивать порядок событий на фронте.

---

## 2. Бинарный протокол (MessagePack / Protobuf)

**Суть:** отдавать те же данные не в JSON, а в бинарном формате. MessagePack уже используется в проекте (Redis, POST `/strokes` с `Content-Type: application/msgpack`). GET `/events` пока всегда `res.json(payload)`.

**Что сделать:**
- **Бэкенд (event-store):** проверять `Accept: application/msgpack`. Если есть — сериализовать `payload` через `msgpackEncode()` и отдать с `Content-Type: application/msgpack` (тело — Buffer).
- **Фронт:** при запросе событий указывать `Accept: application/msgpack`, парсить ответ через `@msgpack/decode` (или аналог). Структура объекта та же (events, roomId, roomName), только формат другой.

**Ожидаемый эффект:** размер тела обычно на **30–50% меньше** JSON при том же содержимом; парсинг на клиенте быстрее.

**Плюсы:** один заголовок и один ветка на бэке, фронт один раз научить приём msgpack.  
**Минусы:** отладка по «сырому» ответу сложнее (нужен декодер).

---

## 3. Сжатие по проводу (gzip / Brotli)

**Уже есть:** в nginx включён `gzip` для `application/json`. То есть **размер по сети** уже меньше (типично 20–40% от размера JSON). В замерах скрипта мы смотрели размер **распакованного** тела (то, что парсит браузер).

**Имеет смысл:**
- Убедиться, что для `application/msgpack` тоже включён gzip (или brotli) в nginx — бинарник часто сжимается ещё лучше.
- Размер в памяти и время парсинга от сжатия не уменьшаются — только трафик.

---

## 4. Ужать структуру данных (короткие ключи, компактные точки)

**Короткие ключи:** в каждом событии повторяются строки `"type"`, `"strokeId"`, `"stroke"`, `"timestamp"`, внутри stroke — `"id"`, `"ts"`, `"tool"`, `"color"`, `"width"`, `"points"`. Замена на 1–2 символа (`t`, `s`, `p` …) даёт заметную экономию при десятках тысяч событий, но ломает читаемость и требует договорённости фронт/бэк.

**Точки:** вместо `[[x,y],[x,y],...]` хранить/отдавать flat-массив `[x1,y1,x2,y2,...]` или целые числа (координаты × 100). Меньше символов и (при int) меньше байт в msgpack.

**Рекомендация:** если вводить короткие ключи — делать это вместе с бинарным протоколом и одной схемой (например описать в shared-типах или .proto).

---

## 5. Не тащить лишнее в каждом событии

**Сейчас:** в ответе GET `/events` каждое событие имеет вид `{ type, strokeId, stroke, timestamp }`. Для `stroke_erased` в `stroke` лежит `{ hiddenPointIndices: number[] }`; для `stroke_created` — полный объект stroke (id, ts, tool, color, width, points, …).

**Проверить:** не отдаётся ли в каких-то типах событий полный stroke там, где достаточно strokeId + минимум полей. Если где-то в ответе дублируется полный stroke без необходимости — убрать и сократить структуру только до нужных полей.

---

## 6. Кэш и условные запросы (ETag / 304)

Для сценария «повторно открыл ту же комнату»:
- Бэкенд по `GET /events?roomId=1&since=0` считает ETag (например хэш от последнего `timestamp` или от контента).
- Клиент при повторном заходе шлёт `If-None-Match: <etag>`.
- Если данные не менялись — ответ `304 Not Modified` без тела.

Эффект: повторные заходы в ту же комнату не качают 19 MB заново.

---

## 7. Приоритет внедрения (кратко)

| Что | Сложность | Эффект |
|-----|-----------|--------|
| Уменьшить чанк / пагинация на фронте | Средняя | Размер одного ответа в разы меньше, быстрее первый показ |
| Tiles-first, события порциями или since | Средняя | Не грузить полный лог для «первой краски» |
| GET /events в MessagePack (Accept) | Низкая | −30–50% размер, быстрее парсинг |
| Gzip для msgpack в nginx | Низкая | Меньше трафика |
| Короткие ключи + flat points | Высокая | Доп. экономия размера |
| ETag / 304 для since=0 | Средняя | Нулевой трафик при повторном заходе без изменений |

Оптимальный быстрый набор: **меньший чанк (или tiles-first) + MessagePack для GET /events** — уже сильно снизят и размер ответа, и время до первого отображения.

---

## Внесённые изменения (реализовано)

- **event-store:** GET `/events` при `Accept: application/msgpack` отдаёт msgpack вместо JSON; добавлена `sendEventsPayload(res, payload, acceptHeader)`.
- **frontend-v2:** пагинация по 500 событий + **бинарный формат**: зависимость `msgpack-lite` (Node 16–совместимый), `ApiService.getStrokes(..., useMsgpack=true)` шлёт `Accept: application/msgpack` и декодирует ответ через `msgpack.decode()`. Чанк ~6 MB в JSON → ~3–4 MB в msgpack.
- **nginx:** в `gzip_types` добавлен `application/msgpack`.
- **frontend-v2 Dockerfile:** `npm install --legacy-peer-deps` (lockfile был рассинхронизирован, peer-конфликты angular-eslint).

Откат: `git checkout -- services/event-store/src/index.ts frontend-v2/src/ frontend-v2/Dockerfile nginx/nginx.conf`.
